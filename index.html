<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>PMP λ₀-style demo (Konva.js)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://unpkg.com/konva@9/konva.min.js"></script>
<style>
  :root { color-scheme: dark; }
  body { margin:0; background:#121216; color:#e8e8ee; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; }
  #ui { position:fixed; left:10px; top:10px; font-size:14px; line-height:1.4; z-index:2; }
  #container { width:100vw; height:100vh; }
  a { color:#9ad }
</style>
</head>
<body>
<div id="ui">
  <div><b>PMP demo (Konva.js)</b></div>
  <div>Left-click (or tap) anywhere to set the target</div>
  <div id="info" style="margin-top:6px;"></div>
</div>
<div id="container"></div>

<script>
/* ========== Config ========== */
const N_DOF = 6;
const LINKS = [0.30,0.25,0.22,0.20,0.18,0.16,0.14,0.12].slice(0,N_DOF);
const Wdiag = Array(N_DOF).fill(1.0);
const Kpdiag = Array.from({length:N_DOF}, (_,i)=> 1.4 - 0.08*i);
const qStar  = Array.from({length:N_DOF}, (_,i)=> (i%2?+0.45:-0.30));
const Ktask = 10;
const DT = 1/120;
const VEL_LIMIT = 10.0;
const PIXELS_PER_M = 220;
const TRACE_LIFETIME = 3000; // ms (5s)
const TRACE_INTERVAL = 50;   // ms between trace dots

/* ========== Utils ========== */
const wrapPi = a => ((a + Math.PI) % (2*Math.PI)) - Math.PI;
function toPx(p, ORIGIN){ return { x: ORIGIN.x + p.x*PIXELS_PER_M,
                                   y: ORIGIN.y - p.y*PIXELS_PER_M }; }
function fromPx(p, ORIGIN){ return { x:(p.x-ORIGIN.x)/PIXELS_PER_M,
                                     y:(ORIGIN.y-p.y)/PIXELS_PER_M }; }

/* FK & Jacobian */
function fkPoints(q){
  const th=[]; let acc=0;
  for(let i=0;i<q.length;i++){ acc+=q[i]; th.push(acc); }
  const joints=[{x:0,y:0}];
  for(let i=0;i<q.length;i++){
    joints.push({
      x:joints[i].x + LINKS[i]*Math.cos(th[i]),
      y:joints[i].y + LINKS[i]*Math.sin(th[i])
    });
  }
  return { joints, ee:joints[joints.length-1] };
}
function jacobian(q){
  const th=[]; let acc=0;
  for(let i=0;i<q.length;i++){ acc+=q[i]; th.push(acc); }
  const N=q.length;
  const Ls=LINKS.map((L,i)=> L*Math.sin(th[i]));
  const Lc=LINKS.map((L,i)=> L*Math.cos(th[i]));
  const Sx=Array(N),Sy=Array(N); let sS=0,sC=0;
  for(let j=N-1;j>=0;j--){ sS+=Ls[j]; sC+=Lc[j]; Sx[j]=-sS; Sy[j]=sC; }
  return [Sx,Sy];
}

/* Small linalg */
function diag(arr){ const n=arr.length,M=Array(n).fill(0).map(()=>Array(n).fill(0)); for(let i=0;i<n;i++) M[i][i]=arr[i]; return M; }
function invDiag(arr){ return diag(arr.map(v=>1/v)); }
function matMul(A,B){ const m=A.length,k=B.length,n=B[0].length,C=Array(m).fill(0).map(()=>Array(n).fill(0));
  for(let i=0;i<m;i++) for(let p=0;p<k;p++){ const a=A[i][p]; if(a===0) continue; for(let j=0;j<n;j++) C[i][j]+=a*B[p][j]; }
  return C;}
function matVec(A,v){ const m=A.length,n=A[0].length,y=Array(m).fill(0); for(let i=0;i<m;i++) for(let j=0;j<n;j++) y[i]+=A[i][j]*v[j]; return y; }
function transpose(A){ const m=A.length,n=A[0].length,T=Array(n).fill(0).map(()=>Array(m).fill(0)); for(let i=0;i<m;i++) for(let j=0;j<n;j++) T[j][i]=A[i][j]; return T; }
function matSub(A,B){ const m=A.length,n=A[0].length,C=Array(m).fill(0).map(()=>Array(n).fill(0)); for(let i=0;i<m;i++) for(let j=0;j<n;j++) C[i][j]=A[i][j]-B[i][j]; return C; }
function eye(n){ const I=Array(n).fill(0).map(()=>Array(n).fill(0)); for(let i=0;i<n;i++) I[i][i]=1; return I; }
function inv2(M){ const [[a,b],[c,d]]=M; const det=a*d-b*c; if(Math.abs(det)<1e-12) throw new Error("Singular"); const invDet=1/det; return [[ d*invDet,-b*invDet],[-c*invDet,a*invDet]]; }

/* PMP step */
function pmpStep(q, xDes){
  const { joints, ee:x }=fkPoints(q);
  const J=jacobian(q); const N=q.length;
  const dx=[xDes.x-x.x, xDes.y-x.y];
  const xdot=[Ktask*dx[0],Ktask*dx[1]];
  const Winv=invDiag(Wdiag);
  const gradH=q.map((qi,i)=>Kpdiag[i]*(qi-qStar[i]));
  const JT=transpose(J);
  const JWinv=matMul(J,Winv);
  const JWJt=matMul(JWinv,JT);
  const JWJtInv=inv2(JWJt);
  const G=matMul(matMul(Winv,JT),JWJtInv);
  const I=eye(N);
  const GJ=matMul(G,J);
  const Nproj=matSub(I,GJ);
  const term1=matVec(G,xdot);
  const term2=matVec(Nproj,matVec(Winv,gradH));
  let qdot=term1.map((v,i)=>v-term2[i]);
  qdot=qdot.map(v=>Math.max(-VEL_LIMIT,Math.min(VEL_LIMIT,v)));
  const qNext=q.map((qi,i)=>wrapPi(qi+qdot[i]*DT));
  return { qNext, joints, ee:x, qdot, xdot };
}

/* Konva scene (auto size) */
const container=document.getElementById('container');
let stageWidth=container.clientWidth;
let stageHeight=container.clientHeight;
let ORIGIN={x:stageWidth/2,y:stageHeight/2+120};

const stage=new Konva.Stage({container:'container',width:stageWidth,height:stageHeight});
const layer=new Konva.Layer(); stage.add(layer);

const hitRect=new Konva.Rect({x:0,y:0,width:stageWidth,height:stageHeight,fill:'rgba(0,0,0,0)',listening:true});
layer.add(hitRect);
const baseDot=new Konva.Circle({x:ORIGIN.x,y:ORIGIN.y,radius:4,fill:'#bbb'}); layer.add(baseDot);
const targetMark=new Konva.Group();
targetMark.add(new Konva.Circle({x:0,y:0,radius:8,stroke:'#ff5a5a',strokeWidth:2}));
targetMark.add(new Konva.Line({points:[-10,0,10,0],stroke:'#ff5a5a',strokeWidth:2}));
targetMark.add(new Konva.Line({points:[0,-10,0,10],stroke:'#ff5a5a',strokeWidth:2}));
layer.add(targetMark);

/* Trace group (multiple fading segments) */
const traceLayer=new Konva.Layer(); stage.add(traceLayer);
let tracePoints=[];

/* Link and joint visuals */
const linkLines=[],jointDots=[];
for(let i=0;i<N_DOF;i++){
  const ln=new Konva.Line({points:[0,0,0,0],stroke:'#e8e8ee',strokeWidth:5,lineCap:'round'});
  linkLines.push(ln); layer.add(ln);
  const jd=new Konva.Circle({x:0,y:0,radius:6,fill:'#7ab4ff'});
  jointDots.push(jd); layer.add(jd);
}
const eeDot=new Konva.Circle({x:0,y:0,radius:7,fill:'#ffdC78'}); layer.add(eeDot);

/* State & interaction */
let q=Array.from({length:N_DOF},(_,i)=>0.20-0.06*i);
let {ee}=fkPoints(q);
let xDes={x:ee.x,y:ee.y};
targetMark.position(toPx(xDes,ORIGIN));

stage.on('pointerdown',(e)=>{
  const pos=stage.getPointerPosition(); if(!pos) return;
  xDes=fromPx(pos,ORIGIN);
  targetMark.position(toPx(xDes,ORIGIN));
  layer.batchDraw();
});

/* Draw robot + trace */
let lastTraceTime=0;
function drawRobot(joints,ee){
  for(let i=0;i<joints.length-1;i++){
    const a=toPx(joints[i],ORIGIN), b=toPx(joints[i+1],ORIGIN);
    linkLines[i].points([a.x,a.y,b.x,b.y]);
    jointDots[i].position(a);
  }
  jointDots[joints.length-2].position(toPx(joints[joints.length-2],ORIGIN));
  const eePx=toPx(ee,ORIGIN);
  eeDot.position(eePx);

  const now=performance.now();
  if(now-lastTraceTime>TRACE_INTERVAL){
    const dot=new Konva.Circle({x:eePx.x,y:eePx.y,radius:2,fill:'#ffdC78',opacity:1});
    traceLayer.add(dot);
    tracePoints.push({node:dot,t:now});
    lastTraceTime=now;
  }

  // fade old dots
  tracePoints=tracePoints.filter(p=>{
    const age=now-p.t;
    if(age>TRACE_LIFETIME){ p.node.destroy(); return false; }
    p.node.opacity(1-age/TRACE_LIFETIME);
    return true;
  });

  layer.batchDraw();
  traceLayer.batchDraw();
}

/* Main loop */
const info=document.getElementById('info');
(function animate(){
  try{
    const {qNext,joints,ee:eeNow,qdot,xdot}=pmpStep(q,xDes);
    q=qNext; drawRobot(joints,eeNow);
    info.textContent=`DoF:${N_DOF} | Target:[${xDes.x.toFixed(3)},${xDes.y.toFixed(3)}] `+
      `EE:[${eeNow.x.toFixed(3)},${eeNow.y.toFixed(3)}] | ‖xdot‖=${Math.hypot(...xdot).toFixed(3)}`;
  }catch(err){ info.textContent='Singularity'; }
  requestAnimationFrame(animate);
})();

/* Resize handler */
window.addEventListener('resize',()=>{
  stageWidth=container.clientWidth; stageHeight=container.clientHeight;
  stage.width(stageWidth); stage.height(stageHeight);
  ORIGIN={x:stageWidth/2,y:stageHeight/2+120};
  baseDot.position(ORIGIN);
  hitRect.width(stageWidth); hitRect.height(stageHeight);
  layer.batchDraw(); traceLayer.batchDraw();
});
</script>
</body>
</html>
